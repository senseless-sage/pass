import{a as C} from"./node_modules/sage-ui/js/page/controller-loader.js";import{K as T,z as P} from"./chunk-b9ed3833cfbeb501.js";function A(x){return document.getElementById(x)}function S(x){const z=document.createElement("template");return z.innerHTML=x,z.content.firstElementChild}function d(x,z,E){if(A("toast-container")===null)document.body.append(S(`
            <x-flex id="toast-container" class="v" style="position: absolute; top: 1rem; right: 1rem;"></x-flex>
        `));const Q="_"+Math.random().toString(36).substring(2,9);A("toast-container").append(S(`
        <x-toast id="toast-${Q}" class="${E}">${x}</x-toast>
    `)),setTimeout(()=>{if(A(`toast-${Q}`).remove(),document.getElementsByTagName("x-toast").length===0)A("toast-container").remove()},z)}async function n(x,z){const E=await T();if(x=P(x),x=x.startsWith(E.pathPrefix)?x.substring(E.pathPrefix.length):x,z!==void 0)C(x,z);window.location.assign(E.pathPrefix+x)}function k(x,z){const E=new TextEncoder,Q=crypto.getRandomValues(new Uint8Array(12)),V={name:"AES-GCM",iv:Q},J=z instanceof Uint8Array?z:E.encode(z);return crypto.subtle.importKey("raw",J,V,!1,["encrypt"]).then((K)=>crypto.subtle.encrypt(V,K,E.encode(x)).then((Z)=>JSON.stringify([...Q,...new Uint8Array(Z)])))}function y(x,z){const E=new Uint8Array(JSON.parse(x)),Q=E.slice(0,12),V=E.slice(12),J=z instanceof Uint8Array?z:(new TextEncoder()).encode(z),K={name:"AES-GCM",iv:Q};return crypto.subtle.importKey("raw",J,K,!1,["decrypt"]).then((Z)=>crypto.subtle.decrypt(K,Z,V).then((Y)=>(new TextDecoder()).decode(Y)))}var O={digest(x,z){const E=new TextEncoder,Q=x instanceof Uint8Array?x:E.encode(x),V=z instanceof Uint8Array?z:E.encode(z);return crypto.subtle.importKey("raw",Q,{name:"PBKDF2"},!1,["deriveBits"]).then((J)=>crypto.subtle.digest("SHA-256",V).then((K)=>crypto.subtle.deriveBits({name:"PBKDF2",salt:K,iterations:262144,hash:"SHA-512"},J,512).then((Z)=>new Uint8Array(Z))))},hex(x,z){return this.digest(x,z).then((E)=>Array.prototype.map.call(E,(Q)=>Q.toString(16).padStart(2,"0")).join(""))}};class q{id;masterPwd;encPwd;accounts;static create(x,z,E){const Q=new q;return Q.id=x,Q.masterPwd=z,Q.encPwd=E,Q.accounts=[],Q}async generateAccPwd(x){const z=(_,X)=>{const $=Array.from(Array(X-_+1),(j,F)=>F+_);return String.fromCharCode(...$).split("")};function E(_,X,$){const j=(X.length-$.length)/2,F=X.slice(j,X.length-j);return _.filter((v)=>F.includes(v)).map((v)=>$[F.indexOf(v)])}const Q=z(48,57),V=z(65,90),J=z(97,122),K=[..."!$%&/()=?{}#+*@-_.,;:"],Z=[..."@#$%*()"],Y=[Q,V,J];if(x.settings.specialChar===D.ALL)Y.push(K);else if(x.settings.specialChar===D.REDUCED)Y.push(Z);const G=[...await O.digest(this.masterPwd,x.name+x.settings.version+"RND_NUMS_PART_1"),...await O.digest(this.masterPwd,x.name+x.settings.version+"RND_NUMS_PART_2")],R=Array.from(new Set(G)).sort((_,X)=>_-X),f=E(G,R,Y.flat()).slice(0,x.settings.length);let b=0;while(!Y.every((_)=>_.some((X)=>f.includes(X))))Y.forEach((_)=>{if(!_.some((X)=>f.includes(X))){const X=Array.from(Array(f.length),(j,F)=>String(F)),$=E(G,R,X)[b];f[$]=E(G,R,_)[b],b++}});return f.join("")}}class I{name;settings;static create(x){const z=new I;return z.name=x,z.settings=H.create(),z}}var D=Object.freeze({ALL:0,REDUCED:1,NONE:2,values(){return Object.values(this).filter((x)=>!(x instanceof Function))},keys(){return Object.keys(this).filter((x)=>!(this[x]instanceof Function))},valueOf(x){return this[x]},keyOf(x){return Object.keys(this).find((z)=>this[z]===x)}});class H{#x;#z;specialChar;userName;customPwd;static create(){const x=new H;return x.version=1,x.length=20,x.specialChar=D.REDUCED,x}get version(){return this.#x}get length(){return this.#z}set version(x){if(x<0)throw new Error("Settings.version cannot be negative.");this.#x=x}set length(x){if(x<0)throw new Error("Settings.length cannot be negative.");this.#z=x}}class M{id;masterPwd;encPwd;constructor(x,z,E){this.id=x,this.masterPwd=z,this.encPwd=E}}function L(x,z,E,Q){const V=new z.constructor,J=new Set(Object.getOwnPropertyNames(V).concat(w(V)));if(E=E===void 0?[]:E,Object.getOwnPropertyNames(x).concat(w(x)).forEach((K)=>{if(E.find((Z)=>Z.srcName===K)===void 0&&J.has(K))E.push(new W(K,K))}),!Q){const K=[],Z=new Set(E.map((Y)=>Y.targetName));if(J.forEach((Y)=>{if(!Z.has(Y))K.push(Y)}),K.length>0)console.error(`No mapping found for target props: "${K}".`)}for(let K=0;K<E.length;K++){if(E[K].targetName===W.IGNORE)continue;if(E[K].srcName===W.NO_SRC)if(E[K].map!==void 0)V[E[K].targetName]=E[K].map(x);else console.error(`Cannot map target prop "${E[K].targetName}". If you use "Mapping.NO_SRC", then you must specify a mapping function.`);else if(E[K].map!==void 0)V[E[K].targetName]=E[K].map(x[E[K].srcName],x);else V[E[K].targetName]=x[E[K].srcName]}return V}var w=function(x){return Object.entries(h(x)).filter((z)=>typeof z[1].get==="function"&&z[0]!=="__proto__").map((z)=>z[0])},h=function(x){if(!x)return Object.create(null);const z=Object.getPrototypeOf(x);return{...h(z),...Object.getOwnPropertyDescriptors(x)}};class W{static NO_SRC="__NO_SRC";static IGNORE="__IGNORE";srcName;targetName;map;constructor(x,z,E){if(z instanceof Function)this.srcName=x,this.targetName=x,this.map=z;else this.srcName=x,this.targetName=z,this.map=E}}class B{version;length;specialChar;userName;customPwd;static from(x){return L(x,this.prototype,[],!0)}static toSettings(x){return L(x,H.prototype,[],!0)}}class N{name;settings;static from(x){return L(x,this.prototype,this.MAPPINGS_FROM_ACCOUNT)}static toAccount(x){return L(x,I.prototype,this.MAPPINGS_TO_ACCOUNT)}static MAPPINGS_FROM_ACCOUNT=[new W("settings",(x)=>B.from(x))];static MAPPINGS_TO_ACCOUNT=[new W("settings",(x)=>B.toSettings(x))]}class U{id;accounts;static from(x){return L(x,this.prototype,this.MAPPINGS_FROM_USER)}static toUser(x){return L(x,q.prototype,this.MAPPINGS_TO_USER)}static MAPPINGS_FROM_USER=[new W("accounts",(x)=>x.map((z)=>N.from(z)))];static MAPPINGS_TO_USER=[new W(W.IGNORE,"masterPwd"),new W(W.IGNORE,"encPwd"),new W("accounts",(x)=>x.map((z)=>N.toAccount(z)))]}function u(x){k(JSON.stringify(U.from(x)),x.encPwd).then((z)=>{localStorage.setItem(x.id,z)})}function l(x,z){const E=localStorage.getItem(x);if(E===null)return new Promise((Q,V)=>{V(new Error(`No user found with id: ${x}`))});return y(E,z).then((Q)=>U.toUser(JSON.parse(Q)))}async function wx(x){return new M(await O.hex(x,"__pass_userId"),Array.from(await O.digest(x,"__pass_mpwd")),Array.from(await O.digest(x,"__pass_encPwd")).slice(32))}function hx(x){return q.create(x.id,new Uint8Array(x.masterPwd),new Uint8Array(x.encPwd))}function ux(x){return l(x.id,new Uint8Array(x.encPwd)).then((z)=>{return z.masterPwd=new Uint8Array(x.masterPwd),z.encPwd=new Uint8Array(x.encPwd),z})}function m(x){u(x)}function lx(x,z){x.accounts.push(I.create(z)),m(x)}function mx(x,z){const E=x.accounts.find((Q)=>Q.name===z);if(E.settings.customPwd)return new Promise((Q)=>Q(E.settings.customPwd));return x.generateAccPwd(E)}
export{A as f,S as g,d as h,n as i,D as j,q as k,W as l,L as m,N as n,wx as o,hx as p,ux as q,m as r,lx as s,mx as t};
