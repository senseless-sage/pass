function W(_){return!_.startsWith(self.location.origin)}function M(_){return _.split("/").slice(2,3).join("/")}function p(_){const z=_.split("/").slice(3).join("/");return z===""?"":j(z)}function E(_){return _=U(_),_===""?"":j(_.substring(0,_.indexOf("/")))}function h(_,z){return _===z+"/"?"":_.startsWith(z)?_.substring(z.length):_}function c(_){return _!==""&&_.slice(-3)!==".js"&&_.slice(-4)!==".mjs"?_+".js":_}function I(_){return _.charAt(_.length-1)==="/"}function H(_){return _!==""&&!I(_)?_+"/":_}function j(_){return _!==""&&_.charAt(0)!=="/"?"/"+_:_}function A(_){return _!=="/"&&I(_)?_.slice(0,-1):_}function U(_){return _!=="/"&&_.charAt(0)==="/"?_.substring(1):_}function N(_){return _!=="."&&_.charAt(0)==="."?_.substring(1):_}function u(_){return _.substring(0,_.lastIndexOf("/"))}function n(_){return _.substring(_.lastIndexOf("/")+1)}var R="resolvedPathname",O="__router_config",F="__router_cached_files";class G{pathPrefix;listDirContentFunc;pagesPath;pageComponentFolderName;componentsPath;assetPaths;jsPaths;apiPath;mockPath;mockPaths;useMocking;formatHtmlComponents;useCache;autoUpdateCache;language;translationsPath;constructor(_){if(this.listDirContentFunc=_.listDirContentFunc,this.pagesPath=_.pagesPath,this.pageComponentFolderName=_.pageComponentFolderName,this.componentsPath=_.componentsPath,this.assetPaths=_.assetPaths,this.jsPaths=_.jsPaths,this.apiPath=_.apiPath,this.mockPath=_.mockPath,this.useMocking=_.useMocking,this.formatHtmlComponents=_.formatHtmlComponents,this.useCache=_.useCache,this.autoUpdateCache=_.autoUpdateCache,this.language=_.language,this.translationsPath=_.translationsPath,this.assetPaths.push(_.componentsPath,_.translationsPath),_.useMocking)this.jsPaths.push(_.mockPath)}}function k(_,z,J){return!_.useCache?J():caches.open(F+_.pathPrefix).then((Q)=>Q.match(z).then((X)=>{if(X)return X;return J().then((Y)=>{if(Y.status<400)return Q.put(z,Y.clone()).then(()=>Y);else return Y})}))}function L(_){return caches.delete(F+_)}function g(_,z){const J=self.location.origin+z.pathPrefix+_;return k(z,J,()=>fetch(J))}function T(path,config){const listDirContentFunc=eval(config.listDirContentFunc);return listDirContentFunc(path,config).then((_)=>_.filter((z)=>!z.includes("..")&&!z.includes("//")).map((z)=>U(N(encodeURI(decodeURI(z)))))).catch((_)=>{console.warn(_);return})}function e(){return((_,z)=>g(H(_),z).then((J)=>J.status===404?Promise.reject(new Error(`No files found in dir: "${_}".`)):J).then((J)=>J.text()).then((J)=>Array.from(J.matchAll(/<a.*?href=["'](.*?)["']/g)).map((Q)=>Q[1]))).toString()}function _1(_,z,J){return((Q,X)=>{const Y=`https://api.github.com/repos/\$user/\$repo/contents/\$dir/${A(U(Q))}`;return k(X,Y,()=>fetch(Y)).then((V)=>V.json()).then((V)=>{if(V.status==="404")return Promise.reject(new Error(`No files found in dir: "${Q}".`));if(!Array.isArray(V))return V.type==="dir"?[H(V.name)]:[V.name];return V.map((Z)=>Z.type==="dir"?H(Z.name):Z.name)})}).toString().replace("$user",_).replace("$repo",z).replace("$dir",J)}async function C(_,z,J){const Q=await T(_,z);if(Q===void 0)return;for(let X of Q)if(X[X.length-1]==="/")await C(_+X,z,J);else J.add(_.substring(z.mockPath.length,_.length-1))}async function Y1(_){if(_.pathPrefix=E(self.location.pathname),_.useMocking){const z=new Set;await C(H(_.mockPath),_,z),_.mockPaths=Array.from(z)}if(f(_),_.useCache&&_.autoUpdateCache)L(_.pathPrefix);self.skipWaiting()}function f(_){return caches.open(O).then((z)=>z.put(_.pathPrefix?_.pathPrefix:"/",new Response(JSON.stringify(_))))}async function Z1(){const _=E(self.location.pathname),z=await caches.open(O),J=await z.match(_?_:"/");if(J!==void 0)return J.text().then(JSON.parse);const Q=_?await z.match("/"):void 0;return Q===void 0?Promise.reject("No router config found."):Q.text().then(JSON.parse)}function G1(_){return new Response(null,{status:301,headers:{Location:_.slice(0,-1)}})}function B1(){return window.location[R]}function y(_,z){if(z===void 0)return;const J=_.split("/"),Q=z.split("/"),X=J.filter((V)=>!Q.includes(V)),Y=Q.filter((V)=>V.startsWith("%5B")&&V.endsWith("%5D")).map((V)=>V.slice(3,-3));return new Map(Y.map((V,Z)=>[V,X[Z]]))}function H1(_,z){if(z.useCache)L(z.pathPrefix);return _.registration.unregister().then(()=>_.clients.matchAll()).then((J)=>J.forEach((Q)=>Q.navigate(Q.url))).then(()=>new Response(null,{status:301,headers:{Location:_.location.origin+z.pathPrefix}}))}function x(_,z){return Array.from({length:z-_+1},(J,Q)=>_+Q)}async function b(_,z,J){const Q=z.startsWith(_);z=Q?z.substring(_.length):z;let X="/";for(let Y of z.split("/")){if(Y==="")continue;if(await T(_+X+Y,J)!==void 0)X+=Y+"/";else{const Z=_+X,w=await T(Z,J).then(($)=>{if($===void 0)return;const K=$.filter((B)=>B.startsWith("%5B")&&B.endsWith("%5D/")).map((B)=>A(B));if(K.length===0)return;if(K.length>1)throw new Error("You cannot have multiple dynamic subdirectories in the same directory.");return K[0]});if(w===void 0)return;X+=w+"/"}}return X=A(X),Q?_+X:X}function j1(_,z,J){const Q=W(_)?M(_):void 0,X=U(A(Q===void 0?z:Q+z)).split("/");return J.mockPaths.filter((V)=>V.startsWith(Q===void 0?"/same-origin/":"/cross-origin/"+Q)).map((V)=>V.split("/").slice(2)).filter((V)=>V.length===X.length).some((V)=>x(0,X.length).every((Z)=>V[Z]===X[Z]||V[Z].startsWith("%5B")&&V[Z].endsWith("%5D")))}function N1(){const _=new BroadcastChannel(D),z=new BroadcastChannel(v);_.onmessage=(J)=>{import(J.data.url).then((Q)=>Q.default(J.data,y(J.data.path,J.data.resolvedPath))).then((Q)=>{z.postMessage({ok:!0,result:Q})}).catch((Q)=>{z.postMessage({ok:!1,reason:Q})})}}async function R1(_,z,J){const Q=W(J.url)?"/cross-origin/"+M(J.url)+_:"/same-origin"+_,X=new S(await J.text(),J.cache,J.credentials,J.destination,Array.from(J.headers.entries()),J.integrity,J.keepalive,J.method,J.mode,J.redirect,J.referrer,J.referrerPolicy,J.url,self.location.origin+z.pathPrefix+z.mockPath+Q+"/mock.js",_),Y=new BroadcastChannel(D),V=new BroadcastChannel(v);return new Promise((Z)=>{V.onmessage=async(w)=>{if(!w.data.ok){const $=W(J.url)?void 0:await b(z.mockPath+"/same-origin",_,z);if($===void 0||_===$)return Y.close(),V.close(),Z(new Response(w.data.reason,{status:404}));else X.url=self.location.origin+z.pathPrefix+z.mockPath+"/same-origin"+$+"/mock.js",X.resolvedPath=$,Y.postMessage(X)}else return Y.close(),V.close(),Z(new Response(w.data.result,{status:200}))},Y.postMessage(X)})}var D="__mock_file_executor",v="__mock_file_execution_requester";class S{body;cache;credentials;destination;headers;integrity;keepalive;method;mode;redirect;referrer;referrerPolicy;originalUrl;url;path;resolvedPath;constructor(_,z,J,Q,X,Y,V,Z,w,$,K,B,q,P,m,d){this.body=_,this.cache=z,this.credentials=J,this.destination=Q,this.headers=X,this.integrity=Y,this.keepalive=V,this.method=Z,this.mode=w,this.redirect=$,this.referrer=K,this.referrerPolicy=B,this.originalUrl=q,this.url=P,this.path=m,this.resolvedPath=d}}
export{W as u,p as v,h as w,c as x,j as y,A as z,N as A,u as B,n as C,R as D,G as E,k as F,g as G,e as H,_1 as I,Y1 as J,Z1 as K,G1 as L,B1 as M,y as N,H1 as O,b as P,j1 as Q,N1 as R,R1 as S};
